虚拟DOM(VUE/REACT 提升页面性能) + 算法Tree(二叉树，二叉搜索树，平衡树，红黑树...) + 重绘（CTO 滴滴顶级传统）浏览器工作原理 = 顶级公司就业(相遇 , DOM 树).

如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗? 会阻塞页面的显示吗？ 

不会阻塞 DOM 树的合成， 会阻塞页面的显示 

关于下载css文件阻塞的问题，我理解
1. 不会阻塞dom树的构建，原因Html转化为dom树的过程，发现文件请求会交给网络进程去请求对应文件，渲染进程继续解析Html。
2. 会阻塞页面的显示，当计算样式的时候需要等待css文件的资源进行层叠样式。资源阻塞了，会进行等待，直到网络超时，network直接报出相应错误，渲染进程继续层叠样式计算

不同阶段 

webpack ? 从url -》 download html Document  -> 解析出来页面(看到的)  分阶段 
webpack  工作流， 不同的阶段 -》 打包输出dist.js 
网页的显示也一样 

1. DOM 树的合成 (?)   看不到页面， 在内存中， 很快
2. 页面的显示, 重绘， 重排（css处理有关）
浏览器把页面展示（绘制）出来， 工作流程
-  入口是什么？ 页面绘制的入口 index.html 网络子进程 Buffer 
  resolve: ['.html', '.js', '.css']
  html 超文本标记语言   <p>渲染流程</p>
  dom   标签结点(docuemnt.createElement)，  文档节点(docuemnt.createTextNode)
  css   层叠?样式表  stylesheet  p {color: red}
  js   JavaScript      p.style.color="gray"
  document 文档开始， 空白的， DOM树没形成， 渲染树更没有， 布局， 样式没有， js event loop  没有

  webpack  rules , 渲染通过最初的html文档类容， 进行分别处理
  为什么有标签就可以？  


- 不同类型的文件， 不同的loader, 
  每个阶段？ 
  类比： 
  webpack 
  - 开始每个子阶段有输入的内容   .styl  .css  .png .ts
  - 对其进行相应处理    loader 
  - 每个阶段生成输出内容   bundler.js 

  上一个阶段的输出， 会成为下一个阶段的输入 bundle.js 
- 输出是什么？ 


1. 构建DOM 树, 在内存中
  浏览器没办法理解HTML 格式, 
  编程的过程， 数据结构(tree) + 算法 (css selector , js querySelector  查找效率  什么树来解决? 二叉搜索树BST )
2. 样式的计算(Recalculate Style)
    这么多样式要怎么管起来？ 样式表
    选择器， 权重， 层叠
    当浏览引擎接收到css 文本时， text/css 
    document.stylesheets  对象中  json 组织css 规则的
    选择器就是key    value 就是属性值， 
    ele.style.color 
    样式的计算
    - 转换样式表中的属性值， 使其标准化
      body { font-size: 2em}  em css3     px
      font-weight: bold      600
    - 计算每个节点的具体样式
      1. 继承
      2. 层叠
      3. 浏览器默认样式， 及结点样式
3. 布局阶段
  需要计算出DOM 树中可见元素的几何位置， 这个过程叫布局
  第二棵树？ 渲染树 ()
  1. 遍历DOM树的所有结点， 并把这些结点加到布局树中
  2. 布局计算
  双飞翼布局， 阿里 发明 
绘制


渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。


浏览器工作流程『从输入 URL 到页面展示』学习笔记

导航

用户输入

1. 用户在地址栏按下回车，检查输入（关键字 or 符合 URL 规则），组装完整 URL；
2. 回车前，当前页面执行 onbeforeunload 事件；
3. 浏览器进入加载状态。

URL 请求

1. 浏览器进程通过 IPC 把 URL 请求发送至网络进程；
2. 查找资源缓存（有效期内）；
3. DNS 解析（查询 DNS 缓存）；
4. 进入 TCP 队列（单个域名 TCP 连接数量限制）；
5. 创建 TCP 连接（三次握手）；
6. HTTPS 建立 TLS 连接（client hello, server hello, pre-master key 生成『对话密钥』）；
7. 发送 HTTP 请求（请求行[方法、URL、协议]、请求头 Cookie 等、请求体 POST）；
8. 接受请求（响应行[协议、状态码、状态消息]、响应头、响应体等）；
   - 状态码 301 / 302，根据响应头中的 Location 重定向；
   - 状态码 200，根据响应头中的 Content-Type 决定如何响应（下载文件、加载资源、渲染 HTML）。

准备渲染进程

1. 根据是否同一站点（相同的协议和根域名），决定是否复用渲染进程。

提交文档

1. 浏览器进程接受到网路进程的响应头数据，向渲染进程发送『提交文档』消息；
2. 渲染进程收到『提交文档』消息后，与网络进程建立传输数据『管道』；
3. 传输完成后，渲染进程返回『确认提交』消息给浏览器进程；
4. 浏览器接受『确认提交』消息后，移除旧文档、更新界面、地址栏，导航历史状态等；
5. 此时标识浏览器加载状态的小圆圈，从此前 URL 网络请求时的逆时针选择，即将变成顺时针旋转（进入渲染阶段）。

渲染

渲染流水线

构建 DOM 树

1. 输入：HTML 文档；
2. 处理：HTML 解析器解析；
3. 输出：DOM 数据解构。

样式计算

1. 输入：CSS 文本；
2. 处理：属性值标准化，每个节点具体样式（继承、层叠）；
3. 输出：styleSheets(CSSOM)。

布局(DOM 树中元素的计划位置)

1. DOM & CSSOM 合并成渲染树；
2. 布局树（DOM 树中的可见元素）；
3. 布局计算。

分层

1. 特定节点生成专用图层，生成一棵图层树（层叠上下文、Clip，类似 PhotoShop 里的图层）；
2. 拥有层叠上下文属性（明确定位属性、透明属性、CSS 滤镜、z-index 等）的元素会创建单独图层；
3. 没有图层的 DOM 节点属于父节点图层；
4. 需要剪裁的地方也会创建图层。

绘制指令

1. 输入：图层树；
2. 渲染引擎对图层树中每个图层进行绘制；
3. 拆分成绘制指令，生成绘制列表，提交到合成线程；
4. 输出：绘制列表。

分块

1. 合成线程会将较大、较长的图层（一屏显示不完，大部分不在视口内）划分为图块（tile, 256*256, 512*512）。

光栅化（栅格化）

1. 在光栅化线程池中，将视口附近的图块优先生成位图（栅格化执行该操作）；
2. 快速栅格化：GPU 加速，生成位图（GPU 进程）。

合成绘制

1. 绘制图块命令——DrawQuad，提交给浏览器进程；
2. 浏览器进程的 viz 组件，根据DrawQuad命令，绘制在屏幕上。

相关概念

重排

1. 更新了元素的几何属性（如宽、高、边距）；
2. 触发重新布局，解析之后的一系列子阶段；
3. 更新完成的渲染流水线，开销最大。

重绘

1. 更新元素的绘制属性（元素的颜色、背景色、边框等）；
2. 布局阶段不会执行（无几何位置变换），直接进入绘制阶段。

合成

1. 直接进入合成阶段（例如CSS 的 transform 动画）；
2. 直接执行合成阶段，开销最小。


减少重排重绘, 方法很多：
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化


减少重排重绘，相当于少了渲染进程的主线程和非主线程的很多计算和操作，能够加快web的展示。
1. 触发repaint reflow的操作尽量放在一起，比如改变dom高度和设置margin分开写，可能会出发两次重排
2. 通过虚拟dom层计算出操作总得差异，一起提交给浏览器。之前还用过createdocumentfragment来汇总append的dom,来减少触发重排重绘次数。
