## 从12.67s到1.06s的故事
- 前端而言，关注一下指标
  白屏时间，首屏时间，整页时间，DNS时间，CPU占用率
- 性能优化的三大方面
1. 网络传输性能
2. 页面渲染技能
3. JS阻塞性能
- 网页传输性能优化
 navigation timing 检测指标图
 重定向->拉取缓存->DNS查询->简历TCP连接->发送请求->接收响应->处理HTML元素->元素加载完成
 - 展开讨论
  1.1 浏览器缓存     
  
  查询是否有相同的文件
  有：拉取本地缓存
  没有：发送数据请求 请求成功状态码200 在输出
  有缓存，但缓存过期就强缓存 再拉取缓存 之后输出
  有缓存 没过期就查询数据是否有更新
  有更新：发送数据请求 输出
  无更新：协商缓存 状态码304 再拉取缓存 最后输出

  缓存调式时，需要去除面板顶部的disable cache 选项 否则浏览器将始终不会从缓存中拉取数据
  浏览器默认缓存是放在内存的 但内存里的缓存会因为进程的结束或者说浏览器的关闭而清除 而在硬盘里则会被长期保存下去

    etag on;   //开启etag验证
    expires 7d;    //设置缓存过期时间为7天

  缓存时切记 浏览器处理客户请求时，如果命中强缓存 浏览器会直接拉去本地缓存 不会与服务器发生任何通信。简单的来说 如果我们再服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。
  所以我们在构建阶段，需要为我们的静态资源添加md5 hash后缀，避免资源更新而引起的前后端文件无法重复的问题
  1.2 资源压缩打包
  减少请求数，减少请求资源体积，提升网络传输效率

  在Webpack5中，html-webpack-plugin 的功能会像 common-chunk-plugin 那样，被集成到webpack内部，这样我们就不需要再install额外的插件了。

  书写HTML元素的src 或 href 属性时，可以省略协议部分，这样也能简单起到节省资源的目的
  
  不要对图片进行gzip压缩 占用后台大量资源，压缩效果也不可观

  1.3 图片资源优化
  1.3.1.不要在HTML里缩放图像
  在200×200图片容器里使用400×400的图片？？？错 导致网页加速速度下降，同时照成宽带浪费
  尽量固定尺寸
  1.3.2.使用雪碧图（CSS Sprite）
  雪碧图：减少请求数的显著运用。多张图片拼在一起 总体积会比之前的小
  雪碧图插件：webpack-spritesmith
  - 雪碧图思路
  将需要的图标放在一个文件夹内便于管理
  @2x是为了适配视网膜2倍屏的图片资源 webpack-spriptesmith内有专门为适配多倍屏提供的配置项
  需要插件读取文件夹所有的图片资源文件，以文件夹名称为图片名称生成一张雪碧图到指定位置，并且能够正确使用这些雪碧图的css文件
  我们之前放在common文件夹里的图片资源都自动地生成了相应的样式，这些都不需要我们手动处理，``webpack-spritesmith`这款插件就已经帮我们完成了！

  1.3.4.使用WebP
  加快图片加载速度的图片格式
  图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间
  1.4.网络传输性能检测工具——Page Speed
  1.5.使用CDN
  再好的性能优化实例，也必须在CDN的支撑下才能到达极致
2.3.重排与重绘
①重排（reflow）：渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口的尺寸发生变化、删除或添加DOM元素，修改了影响元素盒子大小的CSS属性（诸如：width、height、padding）。
②重绘（repaint）：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。
不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。
3. 优化策略
- css读写分离
浏览器没次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用JS对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用JS去操作元素样式，这也是我最推荐的。
- 通过切换class或者style.csstext属性去批量操作元素样式
- DOM元素离线更新
当对DOM进行相关操作时，例如innerHTML、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作。
- 将没用的元素设置不可见
visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示。
- 压缩DOM的深度
一个渲染层内不要有过深的子元素，少用DOM完成页面样式，多使用伪元素或者box-shadow取代。
- 图片在渲染前指定大小
因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。
- 对页面可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力。
（这项策略需要慎用，得着重考量以牺牲GPU占用率能否换来可期的性能优化，毕竟页面中存在太多的渲染层对与GPU而言也是一种不必要的压力，通常情况下，我们会对动画元素采取硬件加速。）
4. pm2实现Node.js“多线程”
pm2.keymetrics.io/ 
它是一款node.js进程管理器，具体的功能，就是能在你的计算机里的每一个内核都启动一个node.js服务，也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个node.js服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。听
