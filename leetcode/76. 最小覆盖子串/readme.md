- 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

- 示例：

输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"

- 说明：

如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。


## 解题思路
1. 要在S字符串中找出包含T所有字母的最小字符串，那么就要先记录T中有哪些字符，然后再去遍历S，从S寻找包含T所有字母的子串。
2. 我们先用map，needs来记录T中的字符，以及字符的数量。
3. 然后维护一个窗口，用索引l,r来表示这个窗口的左右边界，刚开始窗口的大小为0，即l = 0,r = 0;
4. 然后开始遍历S，从窗口的右侧一次放入元素，也用一个map,windows来记录S中的字符以及字符的数量。
5. 如果windows[c1] = need[c1],则说明窗口有一个字符的数量与T中相等，则将计数器count++
6. 如果count等于needs中的key的数量和，则说明窗口中有T中所有的字符串，此时窗口所包含的子串就是一个包含T所有字母的子串。
7. 由于答案是要寻找最小的子串，所以可以记录下符合要求的子串的起始位置以及其长度，其实位置就是l，长度为r - 1 ;
8. 找到符合要求的子串后，就开啥从窗口的左侧移除字符，知道该子串不符合要求，根据将要移除的字符c，判断windows[c] === needs[c],如果相等则将计数器count--，然后移除该字符windows[c]--,最后将左边界索引l++
9. 重复上面的逻辑找出所有可能的子串，比较每一个字串的长度，最后返回最小的子串。