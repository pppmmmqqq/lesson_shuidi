- 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]


## 思路
- 一看到子数组和，有必要马上想到前缀和。

1. 什么是前缀和？？

- 从数组第0项到当前项的总和。
- 如果用一个数组Presum表示
- preSum[0]：数组A 第 0 项 到 第 0 项 的总和
- preSum[1]：数组A 第 0 项 到 第 1 项 的总和
- preSum[2]：数组A 第 0 项 到 第 2 项 的总和
- preSum[3]：数组A 第 0 项 到 第 3 项 的总和
- …… 于是有：
preSum[i] = A[0] + A[1] +…+A[i]
preSum[i]=A[0]+A[1]+…+A[i]

- 所以有：
A[i] = preSum[i] - preSum[i - 1]
A[i]=preSum[i]−preSum[i−1]

- 所以有：
A[i] +…+A[j]=preSum[j] - preSum[i - 1]
A[i]+…+A[j]=preSum[j]−preSum[i−1]

- i 当然可以为 0，此时 i - 1 为 - 1，我们让 preSum[-1] 为 0，此时：
A[0] +A[1]+…+A[j]=preSum[j]
A[0]+A[1]+…+A[j]=preSum[j]

- 这么做的目的：让边界情况也能套用通式（通式也能成立）

### 题目等价转换，目标更清晰

- 子数组的元素之和，就是，第 i 项 到 第 j 项 的和

- 元素之和能被 K 整除的子数组数目 等价于 有几种 i、ji、j 组合，使得第 i ~ j 项的和能被 K 整除

↓ ↓ ↓ 转化为 ↓ ↓ ↓

- 有几种 i、ji、j 组合，满足 (preSum[ j ] - preSum[ i - 1 ])mod K== 0(preSum[j]−preSum[i−1])modK==0

等价于 pre[j] mod K == pre[i-1] mod K

### preSum 数组的每一项，怎么求？
- 前一项的前缀和，累加当前项，就是当前项的前缀和
- 求出的 preSum 数组项让它 mod K，mod 完再看哪两项相等，统计计数
- 但通式有 i、ji、j 两个变量，找出所有相等的两项，需要两层循环，母汤哦~


### 抛弃 preSum 数组，引入哈希表

- 因为我们不关心 前缀和 对应数组 A 的哪一项，即 不关心具体位置
- 我们只关心出现过哪些 前缀和 % K 的结果，和对应的 出现次数
- 用一个变量 preSum ，保存每次求出的前缀和 mod K，存入哈希表
map 不含多余信息，键值对：
key：前缀和 mod K 。数值作为 key
value：这个结果值出现了几次

### 核心流程
- 预置边界情况 (即之前提到的 preSum[-1] = 0)：遍历数组 A 之前，map 提前放入 0:1，代表【前缀和 mod k == 0】已经出现 1 次
- 遍历数组 A 的每一项，求当前项的前缀和 mod k ，存入 map 中
之前没有存过，则作为 key 存入，值为 1
之前存过，则对应值 +1
- 边存边查看 map ，如果 map 中已存在 key 为 当前前缀和 mod K
说明存在 之前求出的前缀和，它 mod K == 当前前缀和 mod K
把 之前求出的前缀和 mod K 出现的次数，累加给 count

一句话总结
根据 当前前缀和 mod k，在 map 中寻找与之相等的 key（目标前缀和 mod K） 。满足该条件的 key ，可能出现不止 1 次，假设为 n 次，就等价于，找到 n 个子数组的元素和能被 K 整除。遍历数组 A 每一项， n 不断累加给 count，最后返回 count


