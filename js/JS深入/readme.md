## javascript的数据是如何存储的？
- 一般来说：基本类型使用栈存储，引用类型使用堆存储。
- 对于闭包变量来说，如果变量存在栈中，函数调用结束栈顶空间销毁，那闭包变量就没有了。
> 闭包变量是存在堆内存的
- 具体来说以下数据类型是存在栈中：
  1. boolean
  2. number
  3. null
  4. undefined
  5. symbol
  6. string 
  7. bigint
   而所有对象数据类型存储在堆中

### 为什么不全部使用栈来保存？
- 如果使用栈来存储相对基本类型跟该复杂的对象数据，那么`切换上下文开销就会变得巨大`
- 堆内存虽然空间大，能存放大量的数据，但同时垃圾内存的挥手会带来更大的开销。

## 垃圾回收机制(GC)grabage collection
`使用不当的闭包会造成内存泄漏`

`程序不用的内存空间`就成为垃圾，工作在javascript引擎内部，悄无声息的。

1. GC做了什么：
- 找到内存空间中的垃圾
- 回收垃圾，让程序员能够再次利用这部分空间

2. 为什么使用GC：
   "省事儿"

3. 为什么学习GC：
   为了更好的找BUG

- 必备的概念
  - 堆是用来存放引用数据类型的
  - mutator: 代表程序本身
  - allocator: 负责从堆中调取足够的空间提供给      mutator使用

  mutator -> allocator -> HEAP

- 活动对象和非活动对象
```js
var a = { name: 'bar' } // 对象被a引用，是活动对象
a = null; // 这个对象没有被a引用，非活动对象
```

## 几种GC算法
### 引用计数法
让所有对象实现记录下有多少程序在引用自己，让个对象知道自己的人气指数。
```js
var a = new Object(); // 对象的引用计数是 1 ( a )
var b = a; // 对象的引用计数是 2 (a, b)
a = null; // reference_count = 1
b = null; // reference_count = 0
```
- 优点：
  1. `可立刻回收垃圾`。
  2. 因为是即时回收，那么“程序”不会暂停很长一段时间的GC，那么最大暂停时间很短。
  3. 不用去遍历堆里面所有活动对象和非活动对象。
- 缺点：
  1. 计数器占很大的位置。
  2. 无法解决循环引用无法回收的问题。

### 标记清除算法
主要GC的垃圾回收过程分为两个阶段：
- 标记阶段：把所有的活动对象进行标记
- 清除阶段：把所有的非活动对象进行销毁

1. 根：全局作用域

- 优点：
1. 解决了循环引用无法回收的问题。
2. 实现简单，打标记也就是打与不打两种可能，可以使用二进制位表示
- 缺点：
1. 造成碎片化
2. 分配次数多：没有找到合适的内存块大小，就会一直遍历到尾端。

GC方式是一个定时运行的任务，当陈鼓型运行一段时间后，会统一GC。

### 复制算法
将某个空间的活动对象复制到其他空间。
将内存分为两个部分：FROM空间和TO空间。FROM空间里的活动对象复制到TO中，然后再释放FROM空间，此时就将FROM和TO空间的身份互换，就完成了GC。

### 其它算法：复制；标记-清除；压缩




## 描述下V8执行一段JS代码的过程

1. 生成AST树(抽象语法树)
生成AST分为两步：词法分析和语法分析
`词法分析就是分词`，将一行行代码分解成一个个Token。
`语法分析就是将生成的Token数据，根据规则转换为AST`，生成AST之后，编译器/解释器后续的工作都要依靠AST而不是源码。
babel: ES6 -> AST; 
       ES6 AST -> ES5 AST; 
       ES5 AST -> ES5代码
2. 生成字节码
生成AST之后，直接通过V8的解释器来生成字节码，`但是字节码并不能让AST直接运行`
V8早期是直接把AST转换成机器码，但是机器码体积太大，引发了严重的内存占用问题。
字节码是比机器码轻量的代码
> 字节码是介于AST和机器码之间的一种代码。

3. 执行代码
字节码解释执行的阶段
在执行字节码的过程，如果一部分代码重复出现，V8将它记为`热点代码`。然后这段代码编译成机器码保存起来，这个编译的工具就是V8的编译器。
因此在这样的机制下，代码执行越久，执行效率越高，越来越多的字节码被标记位`热点代码`。遇到他们的时候不用转换机器码，直接执行。
这种字节码跟编译器和解释器结合起来的技术叫做`即时编译`，也就是`JIT`

## 总结
- 生成AST
- 将AST转换为字节码
- 由解释器逐行执行代码，碰到热点代码就启动编译器编译，转换为机器码，这样极大的提高了效率。